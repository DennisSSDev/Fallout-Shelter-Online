
// -- user code here --

/* --- start generated code --- */

// Generated by  1.5.2 (Phaser v2.6.2)


class AI_manager extends Phaser.Sprite {
	/**
	 * AI_manager
	 * @param {Phaser.Game} aGame A reference to the currently running game.
	 * @param {Number} aX The x coordinate (in world space) to position the Sprite at.
	 * @param {Number} aY The y coordinate (in world space) to position the Sprite at.
	 * @param {any} aKey This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.
	 * @param {any} aFrame If this Sprite is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.
	 */
	constructor(aGame, aX, aY, aKey, aFrame, startingOutCharacterCount) {
		super(aGame, aX, aY, aKey || 'share2', aFrame  == undefined || aFrame == null? null : aFrame);
		this.renderable = false;
		this.validFloors = {'0': 392, '1': 596};//secretly there should only be 2 valid floors for now
		this.round = 0;
		this.requestKillAll = false;
		this.citizenTypes = Object.seal({
			'0': 'adventurer_tilesheet',
			'1': 'female_tilesheet',
			'2': 'player_tilesheet',
			'3': 'soldier_tilesheet'
		});
		this.monsterTypes = Object.seal({
			'0': 'alienBeige',
			'1': 'alienBlue',
			'2': 'alienGreen',
			'3': 'alienYellow'
		});
		this.alarm = this.game.add.audio("FoS_Alarm");
		this.battleMusic = this.game.add.audio("Under_Attack");
		this.citizenDeathSound = this.game.add.audio("groan");
		this.newMemberSound = this.game.add.audio("new_member");
		this.aliveCitizens = [];
		this.aliveEnemies = [];
		this.weapons = []
		this.allBullets = [];
		this.stateRandomizer = -1;
		this.spawnCitizen(startingOutCharacterCount);
		this.totalEnemyCount = startingOutCharacterCount;
		game.time.events.loop(Phaser.Timer.QUARTER, this.ai_Update, this);
		game.time.events.loop(40000, this.checkCitizenStatus, this);
		setTimeout(()=>{
			this.beginRound();
		}, 2000);
	}
	ai_Update(){
		this.aliveCitizens.forEach(
				c => {
					if(c.CURRENT_STATE != c.AI_STATES.DEAD 
							&& c.CURRENT_STATE == c.AI_STATES.IDLE 
							&& c.CURRENT_STATE != c.AI_STATES.UNDER_ATTACK 
							&& !c.executing_command)
					{
						let outRand = this.getRandomInt(0,101);
					
						if(outRand <= 40){
							outRand = 0;
						}
						else if(outRand > 40 && outRand <= 90){
							outRand = 2;
						}
						else if(outRand > 90){
							outRand = 1
						}
						else{
							outRand = 0;
						}
						c.CURRENT_STATE = outRand;
					}
				}
		);
	}
	
	checkCitizenStatus(){
		if(this.game.power_bar.status < .224 || this.game.housing_bar.status < .224){
			//pick an random citizen and kill him
			let pick_citizen = this.getRandomInt(0, this.aliveCitizens.length);
			this.aliveCitizens[pick_citizen].kill();
			this.citizenDeathSound.play();
			this.aliveCitizens.splice(pick_citizen, 1);
		}
		else if(this.game.power_bar.status >= .400 && this.game.housing_bar.status >= .400){
			//add a new citizen or increase the cost of a citizen, but add skill to him
			
			console.log("I'm in here");
			this.newMemberSound.play();
			if(this.aliveCitizens.length < 7){
				this.spawnCitizen(1);
			}
			else{
				let pick_citizen = this.getRandomInt(0, this.aliveCitizens.length);
				this.aliveCitizens[pick_citizen].cost += this.getRandomInt(1,6);
				this.aliveCitizens[pick_citizen].skill += this.getRandomInt(1,9);
			}
			
		}
	}
	
	beginRound(){
		
		this.round++;
		this.totalEnemyCount = this.round*2;
		
		this.totalEnemyCount = this.clamp(this.totalEnemyCount, 1, 9);
		setTimeout(()=>{
			this.game.background_music.fadeOut(2000);
			this.alarm.fadeIn(1000);
			this.battleMusic.fadeIn(2000);
			this.spawnEnemies(this.totalEnemyCount);//add roud into this later
			this.game.alertMessage.alpha = 1;
			this.alertCitizens();
		}, 10000);
		// make all alive payers alarmed
	}
	
	alertCitizens(){
		this.aliveCitizens.forEach(c => {c.CURRENT_STATE = c.AI_STATES.UNDER_ATTACK});
	}
	
	spawnEnemies(amount){
		this.aliveEnemies = [];
		let randXpos = -1;
		for(let i = 0; i < amount; i++)
		{
			randXpos = this.getRandomInt(-350, 80);
			this.aliveEnemies.push(new enemy(this.game, randXpos, this.validFloors[this.getRandomValidFloor()], this.monsterTypes[this.getRandomInt(0,4)], null, this.getRandomInt(3500, 6500), this.round + this.getRandomInt(1, 7), this.round));//randomize stats
		}
		this.aliveEnemies.forEach(c => {this.game.add.existing(c)});
	}
	
	spawnCitizen(amount) {
		let selectedSkin = '';
		let randSkin = -1;
		let randXpos = -1;
		for(let i = 0; i < amount; i++)
		{
			randSkin = this.getRandomInt(0, 4);
			randXpos = this.getRandomInt(401, 1199);
			this.aliveCitizens.push(new citizen(this.game, randXpos, this.validFloors[this.getRandomValidFloor()], this.citizenTypes[this.getRandomInt(0,4)]));
		}
		this.aliveCitizens.forEach(c => {this.game.add.existing(c); this.weapons.push(c.weapon);});
	}
	
	getRandomInt(min, max) {
		  min = Math.ceil(min);
		  max = Math.floor(max);
		  return Math.floor(Math.random() * (max - min)) + min;
	}
	
	getRandomValidFloor(){
		let randFloor = Math.random();
		if(randFloor < .5)
			randFloor = 1;
		else
			randFloor = 0;
		return randFloor;
	}
	//update that manages everything related to ai and it's affect on the world
	update(){
		this.aliveEnemies.forEach(e => {
			if(e != null){
				if(e.x > 1200){
					e.x = -100;
					e.kill();
					this.totalEnemyCount--;
					e = null;
				}
			}
		});	
		if(this.totalEnemyCount <= 0){
			this.requestKillAll = false;
			this.game.alertMessage.alpha = 0;
			this.aliveCitizens.forEach(c => {
				c.CURRENT_STATE = c.AI_STATES.IDLE;
				c.executing_command = false;
			});
			this.game.background_music.fadeIn(2000);
			this.battleMusic.fadeOut(2500);
			this.beginRound();
		}
		else{
			this.allBullets = [];
			this.weapons.forEach(c => {
				this.allBullets = this.allBullets.concat(c.bullets);
			});
			this.game.physics.arcade.collide(this.aliveCitizens, this.aliveEnemies, this.collisionCallback, null, this);
			this.game.physics.arcade.collide(this.allBullets, this.aliveEnemies, this.bulletCollisionCallback, null, this);
			if(this.game.globalBlocker != undefined)
				this.game.physics.arcade.collide(this.aliveEnemies, this.game.globalBlocker);
		}
		if(this.aliveCitizens.length <= 0){
			this.game.gameOverScreen.alpha = 1;
			this.game.world.bringToTop(this.game.gameOverScreen);
			this.game.gameOverScreen.children[0].input.enabled = true;
			this.game.gameOverScreen.x = this.game.camera.x;
			this.game.gameOverScreen.y = this.game.camera.y;
		}
		
		this.calculateBars();
	}
	
	calculateBars(){
		let energy_room_gen = 0;
		let housing_room_gen = 0;
		let citizen_cost = 0;
		
		if(this.game.all_rooms.length > 0){
			this.game.all_rooms.forEach(r => {
				if(r.room_key == 'energy_room'){
					energy_room_gen += r.stats;
				}
				else if(r.room_key == 'housing_room'){
					housing_room_gen += r.stats;
				}
			});
			this.aliveCitizens.forEach(c => {
				citizen_cost += c.cost;
			});
			let housing_total_cost = housing_room_gen - citizen_cost;
			let energy_total_cost = energy_room_gen - citizen_cost;
			
			this.game.power_bar.increaseBar(energy_total_cost/15000); 
			this.game.housing_bar.increaseBar(housing_total_cost/15000);
		}
	}
	
	destroyAll(location){
		this.aliveEnemies.forEach( e => {
				if(Math.abs(e.x - location) < 55){
					if(e != null){	
						e.x = -100;
						e.kill();
						this.totalEnemyCount--;
						e = null;
					}
				}
			}
		);
	}
	
	collisionCallback(c,e){//c for citizen, e for enemy
		c.CURRENT_STATE = c.AI_STATES.DEAD;
		let index = this.aliveCitizens.indexOf(c);
		c.kill();
		this.citizenDeathSound.play();
		this.aliveCitizens.splice(index, 1);
		e.body.velocity.x = 0;
	}
	bulletCollisionCallback(e, b){// b for bullet, e for enemy
		b.kill();
		e.hit();
		if(e.health <= 0){
			e.spawnLoot();
			e.kill();
			this.totalEnemyCount--;
		}
	}
	clamp(num, min, max) {
		  return num <= min ? min : num >= max ? max : num;
	}
	
	
}
/* --- end generated code --- */
// -- user code here --
